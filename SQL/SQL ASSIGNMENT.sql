CREATE DATABASE SCHOOL;
USE SCHOOL;

-- 1. CREATE A TABLE CALLED EMPLOYEES WITH THE FOLLOWING STRUCTURE: 
-- # emp_id(integer,should not be null and should be a primary key).
-- # emp_name(text,should not be null)
-- # age(integer , should have a check constraints to ensure the age is atleast 18)
-- # email(text,should be unique for each employee)
-- # salary(decimal, with a default value of 30000)
-- WRITE THE SQL QUERY TO CREATE THE ABOVE TABLE WITH ALL CONSTRAINTS.

CREATE TABLE EMPLOYEES(
EMP_ID INT NOT NULL PRIMARY KEY,
EMP_NAME VARCHAR(100) NOT NULL,
AGE INT CHECK (AGE >= 18),
EMAIL VARCHAR(200) UNIQUE, 
SALARY DECIMAL(10,2) DEFAULT 30000);

SELECT * FROM EMPLOYEES;

-- 2.EXPLAIN THE PURPOSE OF CONSTRAINTS AND HOW THEY HELP MAINTAIN DATA INTEGRITY IN A DATABASE. PROVIDE EXAMPLES OF COMMON TYPES OF CONSTRAINTS.
-- Constraints help the database stop wrong, incomplete, or duplicate data from being inserted.
-- They maintain data integrity, which means the data remains accurate, meaningful, and dependable at all times.
-- | Constraint  | Purpose                              
 -- PRIMARY KEY | Uniquely identifies each record       
 -- FOREIGN KEY | Maintains relationship between tables 
 -- NOT NULL    | Prevents empty values                 
--  UNIQUE      | Prevents duplicate values             
--  CHECK        | Allows only valid data                
 -- DEFAULT     | Sets automatic value                  

-- 3. WHY WOULD YOU APPLY NOT NULL CONSTRAINTS TO A COLUMN ? CAN A PRIMARY CONTAINS NULL VALUES? JUSTIFY YOUR ANSWER.
-- WE APPLY NOT NULL CONSTRAINTS BECAUSE IT PREVENT EMPTY VALUES IN THE TABLE.
-- PRIMARY KEY SHOULD NOT CONTAINS NULL VALUES. IT MUST BE UNIQUE AND MUST BE NOT NULL.

-- 4.EXPLAIN THE STEPS AND SQL COMMANDS USED TO ADD OR REMOVE CONSTRAINS ON AN EXISTING TABLE. PROVIDE AN EXAMPLES FOR BOTH ADDING AND REMOVING A CONSTRAINTS.
-- # ALTER TABLE EMPLOYEES ADD CONTRAINT CHK_AGE CHECK (AGE >= 18); 
-- # ALTER TABLE EMPLOYEES DROP INDEX EMAIL;

-- 5. EXPLAIN THE CONSEQUENCES OF ATTEMPTING TO INSERT,UPDATE , OR DELETE DATA IN A WAY THAT VIOLATES CONSTRAINTS.
--    PROVIDE AN EXAMPLE OF AN ERROR MESSAGE THAT MIGHT OCCUR WHEN VIOLATING A CONSTRAINTS. 

-- # INSERT INTO EMPLOYEES(EMP_ID, EMP_NAME, AGE)
--   VALUES(NULL, 'RAUSHAN', 20);  # ERROR IS EMP_ID CANNOT BE NULL. 

--  # UPDATE EMPLOYEES SET EMAIL = 'ABC@GMAIL.COM' WHERE EMP_ID IS 109;  # ERROR IS DUPLICATE ENTRY 'ABC@GMAIL.COM' FOR KEY 'EMAIL'.
 
--  # DELETE FROM EMPLOYEES WHERE ID IS 199; # ERROR IS:  Result consisted of more than one row or no row found. 
 
-- 6. YOU CREATED A PRODUCT TABLE WITHOUT CONSTRAINTS AS FOLLOWS:

CREATE TABLE PRODUCTS(
product_id INT,
product_name VARCHAR(50),
price DECIMAL(10, 2));

SELECT * FROM PRODUCTS;
-- NOW , YOU REALISE THAT:
-- # THE product_id should be a primary key. 
-- # The price should have a default value of 50.00. 

 ALTER TABLE PRODUCTS
 ADD constraint pk_product PRIMARY KEY(product_id);
 
 ALTER TABLE PRODUCTS
 MODIFY PRICE DECIMAL(10,2) DEFAULT 50.00;
 
 
-- 7. YOU HAVE TWO  TABLES STUDENT ANDS  CLASSES. WRITE A QUERY TO FETCH THE STUDENT_NAME AND CLASS_NAME FOR EACH STUDENT USING AN INNER JOIN. 
CREATE TABLE STUDENTS(
STUDENT_ID INT PRIMARY KEY,
STUDENT_NAME VARCHAR(150),
CLASS_ID INT NOT NULL);

INSERT INTO STUDENTS VALUES
(1,'ALICE', 101),
(2,'BOB', 102),
(3,'CHARLIE', 101);

CREATE TABLE CLASSES(
CLASS_ID INT ,
CLASS_NAME VARCHAR(150));

INSERT INTO CLASSES VALUES
( 101 , 'MATH'),
(102 , 'SCIENCE'),
(103 , 'HISTORY');

SELECT * FROM STUDENTS;

select * FROM STUDENTS
INNER JOIN CLASSES
ON STUDENTS.CLASS_ID = CLASSES.CLASS_ID;

-- 8. CONSIDER THE FOLLOWING THREE TABLES:
-- WRITE A QUERY THAT SHOW ALL ORDER_ID, CUSTOMER_NAME, AND PRODUCT_NAME,ENSURING THAT ALL PRODUCTS ARE LISTED EVEN IF THEY ARE NOT ASSOCIATED WITH AN ORDER. 

CREATE TABLE ORDERS(
ORDER_ID INT PRIMARY KEY,
ORDER_DATE date,
CUSTOMER_ID INT);

INSERT INTO ORDERS
VALUES
(1, '2024-01-01', 101),
(2, '2024-01-03', 102);

CREATE TABLE CUSTOMERS(
CUSTOMER_ID INT ,
CUSTOMER_NAME VARCHAR(150));

 INSERT INTO CUSTOMERS
VALUES
(101, 'ALICE'),
(102, 'BOB');

TRUNCATE TABLE CUSTOMERS;
 
 CREATE TABLE PRODUCT(
PRODUCT_ID INT auto_increment PRIMARY KEY,
PRODUCT_NAME VARCHAR(150),
ORDER_ID INT);
 
 INSERT INTO PRODUCT
VALUES
(1,'LAPTOP', 1),
(2, 'PHONE', NULL);
 SELECT * FROM CUSTOMERS;
 
 SELECT 
    o.order_id,
    c.customer_name,
    p.product_name
FROM product p
LEFT JOIN orders o
    ON p.order_id = o.order_id
LEFT JOIN customers c
    ON o.customer_id = c.customer_id;
    
-- 9. GIVEN THE FOLLOWING TABLES: WRITE A QUERY TO FIND THE TOTAL SALES AMOUNT FOR EACH PRODUCT USING AN INNER JOIN AND SUM() FUNCTION. 
    
CREATE TABLE SALES(
SALE_ID INT auto_increment PRIMARY KEY,
PRODUCT_ID INT,
AMOUNT INT);

TRUNCATE TABLE SALES;
INSERT INTO SALES VALUES 
(1,101,500),
(2,102,300),
(3,101,700);


CREATE TABLE PRODUC(
PRODUCT_ID INT NOT NULL,
PRODUCT_NAME VARCHAR(150));
 
 INSERT INTO PRODUC
 VALUES
 (101, 'LAPTOP'),
 (102, 'PHONE')
 
  SELECT 
  PRODUC.PRODUCT_NAME,
  SUM(SALES.AMOUNT) AS TOTAL_SALES
  FROM PRODUC
  INNER JOIN SALES
  ON PRODUC.PRODUCT_ID = SALES.PRODUCT_ID
  GROUP BY PRODUC.PRODUCT_NAME;
 
TRUNCATE TABLE PRODUC;
 TRUNCATE TABLE SALES;
 INSERT INTO PRODUC (PRODUCT_ID, PRODUCT_NAME)
 VALUES
(101, 'LAPTOP'),
 (102, 'PHONE');
 INSERT INTO SALES (SALE_ID, PRODUCT_ID, AMOUNT)
 VALUES
 (1,101,500),
 (2,102,300),
 (3,101,700);

 SELECT 
    PRODUC.PRODUCT_NAME,
     SUM(SALES.AMOUNT) AS TOTAL_SALES 
  FROM PRODUC
 INNER JOIN SALES
 ON PRODUC.PRODUCT_ID = SALES.PRODUCT_ID
 GROUP BY PRODUC.PRODUCT_NAME;
 
 -- 10. GIVEN THE FOLLOTABLESWING : WRITE A QUERY TO DISPLAY THE ORDER_ID , CUSTOMER_NAME, AND THE QUANTITY OF PRODUCTS ORDERED BY EACH CUTOMERS USING AN INNER JOI BETWEEN ALL THREE TABLES.as
--  CREATE TABLE ORDER_DETAILS(
 -- ORDER_ID INT NOT NULL,
 -- PRODUCT_ID INT,
 -- QUANTITY INT);
 
  INSERT INTO ORDER_DETAILS VALUES
  (1, 101, 2),
 (1, 102, 1),
  (2,101,3);
  SELECT * FROM ORDER_DETAILS;

 SELECT 
 ORDERS.ORDER_ID,
 CUSTOMERS.CUSTOMER_NAME,
 ORDER_DETAILS.QUANTITY
 FROM ORDERS
 INNER JOIN CUSTOMERS
 ON ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID
 INNER JOIN ORDER_DETAILS  
 ON ORDERS.ORDER_ID = ORDER_DETAILS.ORDER_ID;

 
 